import numpy as np

# curve-fit() function imported from scipy
from scipy.optimize import curve_fit

from matplotlib import pyplot as plt
import sympy

# numpy.linspace with the given arguments
# produce an array of 40 numbers between 0
# and 10, both inclusive
x = np.arange(0.1, 20, 0.1)


y = [
    0.9087299999999999,
    0.9099400000000001,
    0.91052,
    0.9098299999999998,
    0.90933,
    0.9077399999999999,
    0.9089599999999999,
    0.9055500000000001,
    0.9053699999999998,
    0.9023,
    0.90107,
    0.89564,
    0.89064,
    0.8853500000000001,
    0.8764800000000001,
    0.8692399999999999,
    0.8593300000000001,
    0.8501299999999998,
    0.8376899999999999,
    0.8255099999999999,
    0.81074,
    0.7929700000000001,
    0.78604,
    0.76805,
    0.7575799999999999,
    0.7473499999999998,
    0.73273,
    0.7250599999999999,
    0.7099399999999999,
    0.70485,
    0.6948000000000001,
    0.68466,
    0.67794,
    0.6708000000000001,
    0.6671900000000001,
    0.6596299999999999,
    0.6535300000000002,
    0.6490400000000001,
    0.6415400000000001,
    0.6376199999999999,
    0.63403,
    0.63042,
    0.6263399999999999,
    0.6226700000000001,
    0.6232399999999999,
    0.61735,
    0.6138,
    0.6134000000000001,
    0.61056,
    0.607,
    0.60358,
    0.60443,
    0.59968,
    0.59926,
    0.5967100000000001,
    0.5956899999999999,
    0.59231,
    0.5889399999999999,
    0.58911,
    0.5871199999999999,
    0.58789,
    0.58314,
    0.5816199999999999,
    0.58087,
    0.5805199999999998,
    0.5805,
    0.57615,
    0.57501,
    0.57589,
    0.5756600000000001,
    0.57296,
    0.57279,
    0.5704300000000001,
    0.5699099999999999,
    0.5680299999999999,
    0.56741,
    0.56667,
    0.56708,
    0.56522,
    0.5638900000000001,
    0.5629299999999999,
    0.56115,
    0.56462,
    0.5619200000000001,
    0.55908,
    0.55901,
    0.5584999999999999,
    0.55802,
    0.55678,
    0.55731,
    0.55752,
    0.5559200000000001,
    0.5517,
    0.5548799999999999,
    0.55483,
    0.55484,
    0.5549,
    0.55115,
    0.5543699999999999,
    0.5527,
    0.5509700000000001,
    0.5508599999999999,
    0.5488299999999999,
    0.54656,
    0.54781,
    0.54768,
    0.54725,
    0.5455800000000001,
    0.54762,
    0.54698,
    0.54619,
    0.54456,
    0.54657,
    0.54586,
    0.54509,
    0.5428899999999999,
    0.5432,
    0.54237,
    0.5412600000000001,
    0.54122,
    0.54175,
    0.54204,
    0.54145,
    0.53983,
    0.5381599999999999,
    0.5380299999999999,
    0.5387500000000001,
    0.54048,
    0.53979,
    0.53855,
    0.53902,
    0.53666,
    0.5399100000000001,
    0.53791,
    0.53819,
    0.5358799999999999,
    0.5359499999999999,
    0.53742,
    0.53512,
    0.53637,
    0.5367599999999999,
    0.5357799999999999,
    0.53644,
    0.5353000000000001,
    0.53527,
    0.53505,
    0.53259,
    0.53514,
    0.5310600000000001,
    0.5332100000000001,
    0.53069,
    0.5349200000000001,
    0.5326299999999999,
    0.5315799999999999,
    0.53169,
    0.53261,
    0.5313299999999999,
    0.53149,
    0.5311899999999999,
    0.53337,
    0.5320799999999999,
    0.5326099999999999,
    0.53085,
    0.53102,
    0.53015,
    0.53046,
    0.5301,
    0.52867,
    0.53099,
    0.5277700000000001,
    0.5315100000000001,
    0.53033,
    0.5283100000000001,
    0.52865,
    0.52967,
    0.5285599999999999,
    0.52797,
    0.5279799999999999,
    0.5295500000000001,
    0.53024,
    0.52803,
    0.5274699999999999,
    0.5250299999999999,
    0.52858,
    0.52641,
    0.5298299999999999,
    0.52666,
    0.52539,
    0.52729,
    0.52634,
    0.52833,
    0.5277700000000001,
    0.5263000000000001,
    0.52606,
    0.52414,
    0.5243800000000001,
    0.52463,
    0.52408,
    0.52652,
]

# y is another array which stores 3.45 times
# the sine of (values in x) * 1.334.
# The random.normal() draws random sample
# from normal (Gaussian) distribution to make
# them scatter across the base line

import math

# Test function with coefficients as parameters
def test(x, a, b, c, d):
    # return 0.25 * sympy.erf(-(x + a) * b) + 0.75
    return 0.25 * np.tanh(-((x - 2.5) / c)) + 0.75
    # return a * (1 - np.exp(-(b * (x + c)))) ** d


# curve_fit() function takes the test-function
# x-data and y-data as argument and returns
# the coefficients a and b in param and
# the estimated covariance of param in param_cov
param, param_cov = curve_fit(test, x, y, method="lm")


print("curve_fit function coefficients:")
print(param)

# ans stores the new y-data according to
# the coefficients given by curve-fit() function
# guess = test(x, 1, -1)
# ans = param[0] * (np.tanh(-param[1] * x))

plt.plot(x, test(x, *param), label="Fit")
plt.plot(x, y, label="Raw")
# plt.plot(
#     x,
#     test(x, 2.2691, 1, 2.2691),
#     label="Guess",
# )
# plt.plot(x, 0.5 * np.tanh(-3 * x / np.pi + 2.5) + 0.5, label="Guess")

plt.legend()

plt.show()


# [-0.21493656  5.21338892  1.9490138   0.75649915]
# [ 0.22286729 -4.878263   -1.78351026  0.7496535 ]
